<html><head><meta charSet="utf-8"/><title data-react-helmet="true">路由 · WorkerA 1.1 文档  · 看云</title><meta data-react-helmet="true" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/><link rel="stylesheet" href="asset/website.css"/></head><body><div id="main"><div class="root"><div class="window-container"><div class="window-head"><div class="toolbar"><a class="title" href=".">WorkerA 1.1 文档</a><div class="extra"></div></div></div><div class="progress"><div style="width:47.368421052631575%" class="progress-bar"></div></div><div class="window-body"><div class="sidebar"><div class="sidebar-selector"><div class="item active"><i class="icon content"></i>目录</div><div class="item"><i class="icon search"></i>搜索</div></div><div class="sidebar-body"><div class="catalog-body active"><ul><li class=""><div class="wholerow"></div><i class="icon"></i><a href="前言.html" class="text">前言</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="版本说明.html" class="text">版本说明</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="旧版本升级.html" class="text">旧版本升级</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="框架性能.html" class="text">框架性能</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="框架结构说明.html" class="text">目录结构、程序架构</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="配置、安装.html" class="text">配置、安装</a></li><li class="open"><div class="wholerow"></div><i class="icon caret down"></i><a href="基本使用.html" class="text">基本使用</a><ul><li class=""><div class="wholerow"></div><i class="icon"></i><a href="开始.html" class="text">开始</a></li><li class="active"><div class="wholerow"></div><i class="icon"></i><a href="路由.html" class="text">路由</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="控制器.html" class="text">控制器</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="中间件.html" class="text">中间件</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="请求.html" class="text">请求</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="响应.html" class="text">响应</a></li></ul></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="异常处理.html" class="text">异常处理</a></li><li class=""><div class="wholerow"></div><i class="icon caret right"></i><a href="数据库.html" class="text">数据库</a><ul><li class=""><div class="wholerow"></div><i class="icon"></i><a href="数据库配置.html" class="text">数据库配置</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="查询构造器.html" class="text">查询构造器</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="模型.html" class="text">模型</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="Redis.html" class="text">Redis</a></li></ul></li></ul></div><div class="search-body"><div class="search-form"><form class="ui form"><div class="ui small fluid icon input"><input type="text" placeholder="请输入搜索关键词..."/><i class="search icon"></i></div></form></div><div class="search-result"><div class="blankslate"><i class="icon search"></i><p>暂无相关搜索结果！</p></div></div></div></div><div class="sidebar-copyright">本文档使用 <a href="http://www.kancloud.cn" target="_blank">看云</a> 构建</div></div><div class="workspace"><div class="article-wrap"><div class="article"><div class="article-head"><div class="left floated tools"><a class="item icon"><i class="icon align justify"></i></a></div><div class="right floated tools"></div><h1>路由</h1></div><div class="article-body"><p>目录</p>
<div class="markdown-toc"><ul><ul><li><a href="#_4">路由文件</a></li><li><a href="#_10">新建路由</a></li><li><a href="#_32">路由分组</a></li><ul><li><a href="#_37">前缀</a></li><li><a href="#_46">命名空间</a></li><li><a href="#_55">路由中间件</a></li><li><a href="#_67">分组嵌套</a></li></ul><li><a href="#_84">动态路由</a></li><ul><li><a href="#_101">路由缓存</a></li><li><a href="#_105">动态路由会覆盖普通路由吗？</a></li></ul><li><a href="#_112">路由重定向</a></li></ul></ul></div><h2 data-line="4" class="line"><a id="_4"></a>路由文件</h2>
<p>默认的路由文件为项目目录下的 routes/app.php，你可以在这个文件中新建路由。</p>
<p>如果你想新建其它文件来配置路由，请在 routes 目录或其子目录中新建路由文件，然后在 bootstrap/boot.php 中 require 该文件即可。</p>
<h2 data-line="10" class="line"><a id="_10"></a>新建路由</h2>
<p>你可以在路由文件中创建路由，路由支持两种模式：<strong>闭包、控制器@方法</strong>。你可以新建任何 HTTP 支持的方法的路由，如 get、post、put、patch、delete 等。</p>
<p>例子：</p>
<pre><code class="language-php">use WorkerF\Http\Route;
// 闭包
Route::get(&#x27;/test&#x27;, function() {
    return &#x27;hello!&#x27;;
});

Route::put(&#x27;/a/b&#x27;, function() {
    return &#x27;a and b!&#x27;;
});

// 控制器@方法
Route::post(&#x27;/test&#x27;, &#x27;App\Controller\TestController@test&#x27;);
</code></pre>
<p><strong>注：</strong> 虽然闭包路由很方便，但是请不要把业务逻辑都写到路由文件里来，写到控制器中才是最佳实践。</p>
<h2 data-line="32" class="line"><a id="_32"></a>路由分组</h2>
<p>对于多个路由有共同的 path 前缀、命名空间等情况，可以使用 group 方法进行分组。</p>
<h3 data-line="37" class="line"><a id="_37"></a>前缀</h3>
<pre><code class="language-php">use WorkerF\Http\Route;

Route::group([&#x27;prefix&#x27; =&gt; &#x27;/pre&#x27;], function() {
    Route::get(&#x27;/&#x27;, &#x27;App\Controller\TestController@index&#x27;);
    Route::post(&#x27;create/&#x27;, &#x27;App\Controller\TestController@create&#x27;);
});
</code></pre>
<h3 data-line="46" class="line"><a id="_46"></a>命名空间</h3>
<pre><code class="language-php">use WorkerF\Http\Route;

Route::group([&#x27;prefix&#x27; =&gt; &#x27;/pre&#x27;, &#x27;namespace&#x27; =&gt; &#x27;App\Controller&#x27;], function() {
    Route::get(&#x27;/&#x27;, &#x27;TestController@index&#x27;);
    Route::post(&#x27;create/&#x27;, &#x27;TestController@create&#x27;);
});
</code></pre>
<h3 data-line="55" class="line"><a id="_55"></a>路由中间件</h3>
<p>路由中间件需要在配置文件 config/middleware.php 中注册后才能使用，参见 <a href="中间件.html">基本使用 - 中间件</a>。</p>
<pre><code class="language-php">use WorkerF\Http\Route;

Route::group([&#x27;middleware&#x27; =&gt; &#x27;/auth&#x27;,  &#x27;namespace&#x27; =&gt; &#x27;App\Controller&#x27;], function() {
    Route::get(&#x27;/&#x27;, &#x27;TestController@index&#x27;);
    Route::post(&#x27;create/&#x27;, &#x27;TestController@create&#x27;);
});
</code></pre>
<h3 data-line="67" class="line"><a id="_67"></a>分组嵌套</h3>
<p>路由分组支持分组嵌套，你可以灵活的创建路由：</p>
<pre><code class="language-php">use WorkerF\Http\Route;

Route::group([&#x27;prefix&#x27; =&gt; &#x27;/user&#x27;, &#x27;namespace&#x27; =&gt; &#x27;App\Controller&#x27;], function() {

    Route::get(&#x27;login&#x27;, &#x27;TestController@login&#x27;);

    Route::group([&#x27;middleware&#x27; =&gt; &#x27;auth&#x27;], function() {
        Route::get(&#x27;admin&#x27;, &#x27;TestController@index&#x27;);
        Route::post(&#x27;create&#x27;, &quot;TestController@create&quot;);
    });
});
</code></pre>
<h2 data-line="84" class="line"><a id="_84"></a>动态路由</h2>
<p>框架支持动态路由，你可以使用动态路由轻松的实现 RESTful 风格的 WebAPI。</p>
<p>动态路由使用大括号 {} 来传参，参数会依次传入闭包中 (或控制器方法) 中。如：路由 /post/{id} 会匹配任何类似 /post/1、/post/2、/post/something 之类的路径。</p>
<pre><code class="language-php">use WorkerF\Http\Route;

Route::get(&#x27;/post/{id}&#x27;, function($id) {
	return $id;
});

// id 和 name 会依次传入 TestController 的 test 方法中
Route::get(&#x27;/a/{id}/b/{name}&#x27;, &#x27;App\Controller\TestController@test&#x27;);
</code></pre>
<h3 data-line="101" class="line"><a id="_101"></a>路由缓存</h3>
<p>由于动态路由需要对请求的 path 和路由进行正则匹配，需要遍历所有动态路由进行依次匹配，这个过程的时间复杂度是 O(n)，当动态路由的数量增大时性能会线性下降。为了解决这个问题，WorkerA 使用了路由缓存，由于常驻内存程序的特性，框架会直接将新的动态路由请求缓存到内存中，再次访问会直接从缓存中取值，将时间复杂度降到了 O(1)。</p>
<h3 data-line="105" class="line"><a id="_105"></a>动态路由会覆盖普通路由吗？</h3>
<p>Q：例如创建了一个普通路由 /post/goods 和一个动态路由 /post/{name}，当用户请求 /post/goods 时会不会被当作动态路由呢？</p>
<p>A：不会，路由分发时会先检查该路径对应的普通路由是否存在，不存在才会检查动态路由。</p>
<h2 data-line="112" class="line"><a id="_112"></a>路由重定向</h2>
<p>WorkerA 支持路由重定向，你可以使用 WorkerF\Http\Route 类的 redirect($path, $param = []) 方法进行重定向。</p>
<p>注：只有在路由闭包或控制器方法中返回 redirect() 方法的返回值才能有效重定向。</p>
<p>例子：</p>
<pre><code class="language-php">use WorkerF\Http\Route;
use WorkerF\Http\Requests;

Route::get(&#x27;/a&#x27;, function() {
	// 打印重定向请求参数
    $request = new Requests();
    var_dump($request-&gt;name, $request-&gt;age);

	return &#x27;a&#x27;;
});

Route::get(&#x27;/b&#x27;, function() {
    // 重定向到路由 /a
	return Route::redirect(&#x27;/a&#x27;);
});

Route::get(&#x27;/b1&#x27;, function() {
	// 无效操作，执行结果没有被返回
    Route::redirect(&#x27;/a&#x27;);  
	return &#x27;b1&#x27;;
});

Route::get(&#x27;/c&#x27;, function() {
    // 重定向到路由 /a，并传递 GET 参数
	return Route::redirect(&#x27;/a&#x27;, [&#x27;name&#x27; =&gt; &#x27;mike&#x27;, &#x27;age&#x27; =&gt; 23]);
});

</code></pre>
 </div><div class="article-navigation"><span class="prev">上一篇：<a href="开始.html">开始</a></span><span class="next">下一篇：<a href="控制器.html">控制器</a></span></div></div></div></div></div></div></div></div><script src="asset/website.js"></script><script src="asset/plugins/highlight/index.js"></script><script type="application/payload+json">{"config":{"plugins":["highlight"],"price":0,"name":"wazsmwazsm/workera","sha":"0394c7aad780584659700053d4efaba1f4d43a76","title":"WorkerA 1.1 文档","id":70629},"catalog":[{"id":"前言.html","name":"前言.md","title":"前言","depth":1},{"id":"版本说明.html","name":"版本说明.md","title":"版本说明","depth":1},{"id":"旧版本升级.html","name":"旧版本升级.md","title":"旧版本升级","depth":1},{"id":"框架性能.html","name":"框架性能.md","title":"框架性能","depth":1},{"id":"框架结构说明.html","name":"框架结构说明.md","title":"目录结构、程序架构","depth":1},{"id":"配置、安装.html","name":"配置、安装.md","title":"配置、安装","depth":1},{"id":"基本使用.html","name":"基本使用.md","title":"基本使用","depth":1,"children":[{"id":"开始.html","name":"开始.md","title":"开始","depth":2},{"id":"路由.html","name":"路由.md","title":"路由","depth":2},{"id":"控制器.html","name":"控制器.md","title":"控制器","depth":2},{"id":"中间件.html","name":"中间件.md","title":"中间件","depth":2},{"id":"请求.html","name":"请求.md","title":"请求","depth":2},{"id":"响应.html","name":"响应.md","title":"响应","depth":2}]},{"id":"异常处理.html","name":"异常处理.md","title":"异常处理","depth":1},{"id":"数据库.html","name":"数据库.md","title":"数据库","depth":1,"children":[{"id":"数据库配置.html","name":"数据库配置.md","title":"数据库配置","depth":2},{"id":"查询构造器.html","name":"查询构造器.md","title":"查询构造器","depth":2},{"id":"模型.html","name":"模型.md","title":"模型","depth":2},{"id":"Redis.html","name":"Redis.md","title":"Redis","depth":2}]}],"article":{"id":"路由.html","name":"路由.md","title":"路由","content":"目录\n\n[TOC]\n\n## 路由文件\n\n默认的路由文件为项目目录下的 routes/app.php，你可以在这个文件中新建路由。\n\n如果你想新建其它文件来配置路由，请在 routes 目录或其子目录中新建路由文件，然后在 bootstrap/boot.php 中 require 该文件即可。\n\n## 新建路由\n\n你可以在路由文件中创建路由，路由支持两种模式：**闭包、控制器@方法**。你可以新建任何 HTTP 支持的方法的路由，如 get、post、put、patch、delete 等。\n\n例子：\n```php\nuse WorkerF\\Http\\Route;\n// 闭包\nRoute::get('/test', function() {\n    return 'hello!';\n});\n\nRoute::put('/a/b', function() {\n    return 'a and b!';\n});\n\n// 控制器@方法\nRoute::post('/test', 'App\\Controller\\TestController@test');\n```\n\n**注：** 虽然闭包路由很方便，但是请不要把业务逻辑都写到路由文件里来，写到控制器中才是最佳实践。\n\n## 路由分组\n\n对于多个路由有共同的 path 前缀、命名空间等情况，可以使用 group 方法进行分组。\n\n\n### 前缀\n```php\nuse WorkerF\\Http\\Route;\n\nRoute::group(['prefix' => '/pre'], function() {\n    Route::get('/', 'App\\Controller\\TestController@index');\n    Route::post('create/', 'App\\Controller\\TestController@create');\n});\n```\n### 命名空间\n```php\nuse WorkerF\\Http\\Route;\n\nRoute::group(['prefix' => '/pre', 'namespace' => 'App\\Controller'], function() {\n    Route::get('/', 'TestController@index');\n    Route::post('create/', 'TestController@create');\n});\n```\n### 路由中间件\n\n路由中间件需要在配置文件 config/middleware.php 中注册后才能使用，参见 [基本使用 - 中间件](中间件.md)。\n\n```php\nuse WorkerF\\Http\\Route;\n\nRoute::group(['middleware' => '/auth',  'namespace' => 'App\\Controller'], function() {\n    Route::get('/', 'TestController@index');\n    Route::post('create/', 'TestController@create');\n});\n```\n### 分组嵌套\n\n路由分组支持分组嵌套，你可以灵活的创建路由：\n```php\nuse WorkerF\\Http\\Route;\n\nRoute::group(['prefix' => '/user', 'namespace' => 'App\\Controller'], function() {\n\n    Route::get('login', 'TestController@login');\n\n    Route::group(['middleware' => 'auth'], function() {\n        Route::get('admin', 'TestController@index');\n        Route::post('create', \"TestController@create\");\n    });\n});\n```\n\n## 动态路由\n\n框架支持动态路由，你可以使用动态路由轻松的实现 RESTful 风格的 WebAPI。\n\n动态路由使用大括号 {} 来传参，参数会依次传入闭包中 (或控制器方法) 中。如：路由 /post/{id} 会匹配任何类似 /post/1、/post/2、/post/something 之类的路径。\n\n```php\nuse WorkerF\\Http\\Route;\n\nRoute::get('/post/{id}', function($id) {\n\treturn $id;\n});\n\n// id 和 name 会依次传入 TestController 的 test 方法中\nRoute::get('/a/{id}/b/{name}', 'App\\Controller\\TestController@test');\n```\n\n### 路由缓存\n\n由于动态路由需要对请求的 path 和路由进行正则匹配，需要遍历所有动态路由进行依次匹配，这个过程的时间复杂度是 O(n)，当动态路由的数量增大时性能会线性下降。为了解决这个问题，WorkerA 使用了路由缓存，由于常驻内存程序的特性，框架会直接将新的动态路由请求缓存到内存中，再次访问会直接从缓存中取值，将时间复杂度降到了 O(1)。\n\n### 动态路由会覆盖普通路由吗？\n\nQ：例如创建了一个普通路由 /post/goods 和一个动态路由 /post/{name}，当用户请求 /post/goods 时会不会被当作动态路由呢？\n\nA：不会，路由分发时会先检查该路径对应的普通路由是否存在，不存在才会检查动态路由。\n\n\n## 路由重定向\n\nWorkerA 支持路由重定向，你可以使用 WorkerF\\Http\\Route 类的 redirect($path, $param = \\[\\]) 方法进行重定向。\n\n注：只有在路由闭包或控制器方法中返回 redirect() 方法的返回值才能有效重定向。\n\n例子：\n```php\nuse WorkerF\\Http\\Route;\nuse WorkerF\\Http\\Requests;\n\nRoute::get('/a', function() {\n\t// 打印重定向请求参数\n    $request = new Requests();\n    var_dump($request->name, $request->age);\n\n\treturn 'a';\n});\n\nRoute::get('/b', function() {\n    // 重定向到路由 /a\n\treturn Route::redirect('/a');\n});\n\nRoute::get('/b1', function() {\n\t// 无效操作，执行结果没有被返回\n    Route::redirect('/a');  \n\treturn 'b1';\n});\n\nRoute::get('/c', function() {\n    // 重定向到路由 /a，并传递 GET 参数\n\treturn Route::redirect('/a', ['name' => 'mike', 'age' => 23]);\n});\n\n```\n"},"options":{"plugins_host":null,"context":"website","base":"./","features":["search","internal_link"]},"style":""}</script><script type="text/javascript">kancloud.bootstrap();</script></body></html>